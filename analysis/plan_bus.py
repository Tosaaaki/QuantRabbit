"""
In-memory registry for pocket-level plans generated by the main planner.
"""

from __future__ import annotations

from datetime import datetime
import logging
import os
from threading import Lock
from typing import Dict, Optional

from workers.common.pocket_plan import PocketPlan

_PLANS: Dict[str, PocketPlan] = {}
_LOCK = Lock()
_LOG = logging.getLogger(__name__)
_LOG_PUBLISH = os.getenv("PLAN_BUS_LOG", "0").strip().lower() in {"1", "true", "yes", "on"}


def publish(plan: PocketPlan) -> None:
    with _LOCK:
        _PLANS[plan.pocket] = plan
    if _LOG_PUBLISH:
        try:
            _LOG.info(
                "[PLAN] publish pocket=%s signals=%d lot=%.4f range=%s",
                plan.pocket,
                len(plan.signals or []),
                float(plan.lot_allocation or 0.0),
                bool(plan.range_active),
            )
        except Exception:
            pass


def latest(pocket: str) -> Optional[PocketPlan]:
    with _LOCK:
        return _PLANS.get(pocket)


def snapshot() -> Dict[str, PocketPlan]:
    with _LOCK:
        return dict(_PLANS)


class PlanCursor:
    """Utility to consume per-pocket plans in chronological order."""

    def __init__(self) -> None:
        self._last_seen: Dict[str, datetime] = {}

    def consume(self, pocket: str) -> Optional[PocketPlan]:
        plan = latest(pocket)
        if not plan:
            return None
        last = self._last_seen.get(pocket)
        if last and plan.generated_at <= last:
            return None
        self._last_seen[pocket] = plan.generated_at
        return plan

    def peek(self, pocket: str) -> Optional[PocketPlan]:
        return latest(pocket)

    def reset(self, pocket: Optional[str] = None) -> None:
        if pocket is None:
            self._last_seen.clear()
        else:
            self._last_seen.pop(pocket, None)
